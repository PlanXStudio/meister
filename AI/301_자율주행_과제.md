## 라이다 응용 미로 탈출
다음 명령으로 pop 라이브러리를 프로젝트 폴더로 복사
```sh
cp -R /usr/local/lib/python3.8/dist-packages/pop ./serbot2
```

### 라이브러리 수정
**serbot2/driving_base.py**
```python
from .CAN import Can
import math
import numpy as np

class DrivingBase:
    WHEEL_ID = 0x010
    WHEEL_POS = 0x07
    WHEEL_CENTER = 100
    
    SPIN_RIGHT = 0x01
    SPIN_LEFT = 0x02

    def __init__(self,dev='can0',bitrate=500000):
        self.__angle = 0        
        self.steer = 0
        self.__setting_throttle = False
        self.__spin = None
        self.__can = Can(dev,bitrate) 
        self.__stop()

    def __stop(self):
        self.__throttle = 0
        self.wheel_vec = [DrivingBase.WHEEL_CENTER, DrivingBase.WHEEL_CENTER, DrivingBase.WHEEL_CENTER]

    def __move(self):
        if self.__throttle == 0:
            offset = 0
        else:
            offset = np.sign(self.__throttle) * 7

        if (self.__angle == 0) or (self.__angle == 180):
            weight = self.throttle * 1.15
        else:
            weight = self.throttle 
          
        if self.__spin == self.SPIN_RIGHT:
            for i in range(3):
                self.wheel_vec[i] = DrivingBase.WHEEL_CENTER - round((self.throttle + offset) * 0.935)               
        elif self.__spin == self.SPIN_LEFT:
            for i in range(3):
                self.wheel_vec[i] = DrivingBase.WHEEL_CENTER + round((self.throttle + offset) * 0.935)
        else:
            if self.__throttle == 0:
                offset = 0
            else:
                offset = np.sign(self.throttle) * 25

            if (self.__angle == 0) or (self.__angle == 180):
                weight = (self.__throttle + offset) * 0.92  # 1.15 * 100 / 125
            else:
                weight = (self.__throttle + offset) * 0.8  # 100 / 125

            Vx = 1 * math.sin(math.radians(self.__angle)) * weight
            Vy = math.cos(math.radians(self.__angle)) * weight

            self.wheel_vec[2] = DrivingBase.WHEEL_CENTER - round(-1 * Vx)
            self.wheel_vec[0] = DrivingBase.WHEEL_CENTER - round(
                (1 / 2) * Vx + (math.sqrt(3) / 2) * Vy
            )
            self.wheel_vec[1] = DrivingBase.WHEEL_CENTER - round(
                (1 / 2) * Vx - (math.sqrt(3) / 2) * Vy
            )

        self.transfer()
        
    def transfer(self):
        payload = [DrivingBase.WHEEL_POS] + self.wheel_vec
        self.__can.write(DrivingBase.WHEEL_ID, payload)
        
    def move(self, angle, throttle=None):
        if throttle:
            self.throttle = throttle

        if not (angle == 0) or (angle == 180):
            assert abs(self.throttle) >= 20, "Throttle must be >= 20 "
            
        self.__angle = angle
        self.__spin = None
        self.__move()
        
    def rotate(self, throttle=None, spin=None):        
        if throttle:
            self.throttle = throttle
        if spin:
            self.__spin = spin
        self.__move()
            
    def stop(self):
        self.__stop()
        self.transfer()

    @property
    def throttle(self):
        return self.__throttle

    @throttle.setter
    def throttle(self, throttle):
        self.__throttle = throttle
        
        if not self.__setting_throttle:
            self.__move()
```

**serbot2/driving.py**
```python
from .driving_base import DrivingBase

class Driving(DrivingBase):
    ACT_PID = 0x012
    PID_ON = 0xFF
    PID_OFF = 0x00 

    def __init__(self, dev='can0', bitrate=500000):
        super().__init__(dev, bitrate)
        self.__pid = False
        self.steering = 0.0 

    def forward(self, throttle=None):        
        self.move(0,throttle)

    def backward(self,throttle=None):
        self.move(180,throttle)
        
    def spinRight(self,throttle=None):
        self.rotate(throttle, self.SPIN_RIGHT)        

    def spinLeft(self,throttle=None):
        self.rotate(throttle, self.SPIN_LEFT)        

    @property
    def steering(self):
        return((self.wheel_vec[2] - DrivingBase.WHEEL_CENTER)/100) * -1

    @steering.setter
    def steering(self, r):
        assert(-1.0 <= r <= 1.0)
        self.steer = r
        self.wheel_vec[2] = (DrivingBase.WHEEL_CENTER + round(r * 100) * -1)
        self.transfer()

    @property
    def pid(self):
        return self.__pid

    @pid.setter
    def pid(self, on):
        self.__pid = on
        self.__can.write(Driving.ACT_PID, Driving.PID_ON if self.__pid else Driving.PID_OFF)
```

### 과제
라이다로 전방 315 ~ 45(90도 범위), 오른쪽 75 ~ 105(30도 범위), 왼쪽 225 ~ 285(30도 범위) 위치의 충돌을 탐지하는 함수 구현
```python
def detect():
    front_list = []
    right_list = []
    left_list = []
    front = right = left = DANGER
    
    for data in lidar.getVectors():
        if data[0] >= 360 - 45 or data[0] < 0 + 45:
            front_list.append(data[1])
        elif data[0] >= 90 - 15 and  data[0] < 90 + 15:
            right_list.append(data[1])
        elif data[0] >= 270 - 15 and data[0] < 270 + 15:
            left_list.append(data[1])
    
    if front_list:
        front = min(front_list) / 10
    
    if right_list:
        right = min(right_list) / 10
    
    if left_list:
        left = min(left_list) / 10
    
    return front, right, left

def loop():
    front, right, left = detect()
    print(front, right, left, dist) 
```

time.sleep()을 사용하면 지연 시간 동안 detect() 실해을 비롯해 다른 작업을 못하므로, 시간을 카운터하는 방법 적용
```python
t0 = 0
tick_count = 0

def setup():
    global t0
    t0 = time.time()

def loop():
    global t0, tick_count
    
    if time.time() - t0 >= 1:
        tick_count = tick_count + 1
        t0 = time.time()

    if tick_count > 5: #원하는 횟수
        pass #원하는 작업
```

**track.py**
```python
import sys 
import signal
import time

from serbot2.driving import Driving
from serbot2.LiDAR import Rplidar

DANGER = 25

drv = Driving()
lidar = Rplidar()

t0 = 0
tick_count = 0
is_stop = False

def detect():
    front_list = []
    right_list = []
    left_list = []
    front = right = left = DANGER
    
    for data in lidar.getVectors():
        if data[0] >= 360 - 45 or data[0] < 0 + 45:
            front_list.append(data[1])
        elif data[0] >= 90 - 15 and  data[0] < 90 + 15:
            right_list.append(data[1])
        elif data[0] >= 270 - 15 and data[0] < 270 + 15:
            left_list.append(data[1])
    
    if front_list:
        front = min(front_list) / 10
    
    if right_list:
        right = min(right_list) / 10
    
    if left_list:
        left = min(left_list) / 10
    
    return front, right, left

def setup():
    global t0
    
    lidar.startMotor()
    t0 = time.time()
    
def loop():
    global t0, tick_count, is_stop
    
    front, right, left = detect()    
    print(front, right, left)
    
    if time.time() - t0 >= 1: #1sec
        if not is_stop:
            tick_count = tick_count + 1
        t0 = time.time()
        
    else:
        if front <= DANGER:
            if tick_count > 20:
                cleanup()
            else:
                is_stop = True
                drv.stop()
        else:
            is_stop = False
            drv.forward(50)
        
def cleanup(*args):
    drv.stop()
    lidar.stopMotor()
    sys.exit(0)


if __name__ == "__main__":
    signal.signal(signal.SIGINT, cleanup)
    setup()
    while True:
        try:
            loop()
        except:
            break
```

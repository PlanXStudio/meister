# 스마트홈 제어
IoT 기술을 이용해 가정, 빌딩과 같은 실내 환경 제어  
XNode 모트 및 XNode 모듈이 내장된 Auto 제어기와 전공 공급기 및 주변장치로 구성됨

### XNode 모트
- 대표적인 저전력 IoT 통신 기술인 Zigbee 칩이 내장된 Coretex-M 계열 MCU와 배터리, 기본 센서, 확장 포트로 구성
- 개발환경은 파이썬의 하위 집합인 마이크로파이썬 사용 

### Auto 제어기
- 배터리가 제거된 XNode 모듈 내장
  - 전원 스위치 조작 불필요. 리셋 버튼만 사용  
- PWM 컨트롤러 및 릴레이 내장
- 릴레이 및 전원이 포함된 터미널 IO 포트 제공
  - 주변장치의 신호선 또는 전원선을 '_'자 소형 드라이버로 개방해 결선
  - 다양한 전원 (3V3, 5V, 12V, GND) 포트 제공
    - **전원선은 잘못 연결하면 장비 파손 위험**이 있으므로 주의할 것!  

### 전원 공급기
- 12V DC 전원 입력을 최대 3개의 12V DC 전원 출력으로 공급
- 2x16 텍스트LED 내장
- 부가 기능으로 XNode의 하드웨어 인터페이스에 연결된 포트 제공
  - 다양한 전원 (3V3, 5V, 12V, GND) 포트 제공

### 주변장치
**확장 모듈**
- XNode 모트의 확장 포트에 연결해 사용
- 관성 센서(IMU), 비접촉 적외선온도 센서(IRDA), 움직임감지 센서(PIR), 범지구측위 센서(GPS), 기본 IO 장치(LED, 버튼, 부저)  

**Auto 제어기 주변장치**
- Auto 제어기의 릴레이 및 IO 포트에 연결해 사용
- 전원선(12V): 팬(FAN), 조명(Light), 가스 잠금 장치(Gas Circuit Breaker)
- 신호선: 도어락(DoorLock), 가스 감지기(Gas Detector)

## 실습 환경
### XNode 모트
- 한 개의 XNode 모트 사용
  - XNode 모트의 Micro B 포트와 PC의 USB A 포토를 USB 케이블로 연결
    - 만약 PC에 Type C 포트만 제공하면 Type C to USB A 변환기를 별도 준비해야 함
  - PC에서 XNode 모트의 시리얼 포트 확인 
- 여러 개의 XNode 모트 사용
  - 5V USB 허브용 전원 어댑터를 USB 허브에 연결한 후 전용 케이블로 PC(USB 3.0 A 포트)와 USB 허브(USB 3.0 MicroB 포트) 연결.
    - USB 허브의 USB A 포트에 여러 개의 XNode 모트 연결  
  - PC에서 여러 Auto 제어기의 시리얼 포트 확인
    - XNode 모트를 하나씩 연결하면서 확인할 것

### Auto 제어기 
- 한 개의 Auto 제어기 사용
  - 12V DC 전원 입력을 Auto 제어기 전원 포트에 연결
  - Auto 제어기의 Micro B 포트와 PC의 USB A 포토를 USB 케이블로 연결
    - 만약 PC에 Type C 포트만 제공하면 Type C to USB A 변환기를 별도 준비해야 함
  - PC에서 Auto 제어기의 시리얼 포트 확인 
- 여러 개의 Auto 제어기 사용
  - 5V USB 허브용 전원 어댑터를 USB 허브에 연결한 후 전용 케이블로 PC(USB 3.0 A 포트)와 USB 허브(USB 3.0 MicroB 포트) 연결.
    - USB 허브의 USB A 포트에 여러 개의 Auto 제어기 연결  
  - 12V DC 전원 입력을 전공 공급기에 연결한 후 전용 케이블을 각각의 Auto 제어기 전원 포트에 연결
  - PC에서 여러 Auto 제어기의 시리얼 포트 확인
    - Auto 제어기를 하나씩 연결하면서 확인할 것

### 개발 툴 설치
- 마이크로파이썬으로 XNode 모트 및 Auto 제어기에 내장된 XNode 모듈 제어
- 다음 명령으로 전용 툴 설치
```sh
pip install -U xnode genlib s2u quat3d smon
pip install -U micropython-magic
```

### 시작하기
1. scan 명령으로 PC에 연결된 XNode 모트 또는 Auto 제어기의 시리얼 포트 확인
```sh
xnode scan
```
- **실습 장비가 바뀔 때마다 확인**할 것! (com4로 가정)
- 만약 시리얼 포트가 여러개 출력되면 다음과 같이 장치 관리자를 실행한 후 **포트(COM & LPT) > USB Serial PortI(COMx)** 확인
```
devmgmt.msc 
```

2. init 명령으로 처음 사용하는 XNode 모트 또는 Auto 제어기 초기화(포맷 및 전용 라이브러리 설치)
- 해당 장비당 한 번만 수행하며,약 2분정도 소요됨
```sh
xnode --sport com4 init
```

3. ls 명령으로 전용 라이브러리(xnode/pop) 설치 확인
- /flash/lib 경로에 라이브러리 위치  
```sh
xnode --sport com4 ls /flash/lib/xnode/pop
```

4. VSCode에서 새 파이썬 파일(my.py)을 만든 후 코드 작성
```python
def setup():
    print("Start...")

def loop():
    exp = input("> ")
    try:
        ret = eval(exp)
        print(ret)
    except:
        print("Syntax Error")

if __name__ == "__main__":
    setup()
    while True:
        loop()
```

5. 작성한 코드를 run 명령으로 XNode 모트 또는 Auto 제어기에서 실행
```sh
xnode --sport com4 run my.py
```
- 프로그램이 무한 루프일 때 터미널에서 Ctrl+c를 누르면 XNode 툴은 종료하지만, 프로그램은 계속 실행됨.
  - XNode 모트 또는 Auto 제어기의 리셋 버튼을 누르면, 실행 중인 프로그램 강제 종료

6. run과 함께 -ni(또는 -in)을 사용하면 에코 기능이 꺼지므로 입력 문자가 중복 출력되지 않음
```sh
xnode --sport com4 run -ni my.py
```

7. run과 함께 -n을 사용하면 파이썬 코드를 XNode 모트 또는 Auto 제어기에서 실행한 후 바로 xnode 툴 종료
```sh
xnode --sport com4 run -n my.py
```

8. xnode 툴 대신 PuTTY와 같은 시리얼 응용프로그램 사용
```py
winget install PuTTY.PuTTY
```
- 설치가 완료되면 putty를 실행한 후 다음과 같이 설정
  - Connection type: Serial
  - Serial line: COMx,
  - Speed는 115200
  - Open 버튼 클릭
- 앞서 실행 프로그램 테스트 진행
- 주의) **xnode 툴과 putty는 동시에 실행할 수 없음**

9. PC에서 작성한 파이썬 파일을 put 명령으로 XNode 모트 또는 Auto 제어기에 main.py로 옮기기
```sh
xnode --sport com4 put my.py /flash/main.py
xnode --sport com4 ls /flash
```  
- XNode 모트 또는 Auto 제어기에 전원이 공급(또는 리셋)되면, /flash 폴더에 main.py가 있는지 검사 후 있으면 자동으로 실행
- 앞서 설치한 PuTTY로 결과 확인

10. XNode 모트 또는 Auto 제어기의 파일을 rm 명령으로 삭제하기
```sh
xnode --sport com4 rm /flash/main.py
xnode --sport com4 ls /flash
```

## XNode 모트와 시리얼 통신으로 PC 연동
XNode 모트의 확장 포트에 IMU 확장을 꼽은 후 가속도 센서값에 따라 PC 제어 구현

### XNode 모트에서 IMU 센서 제어
관성 센서는 가속도(3축), 각속도(3축), 지자기(3축)으로 구성되며, 자동차, 드론 등에서 충격 감지, 자세 제어 등에 활용
- 가속도(액설러미터): 해당 축 방향에 가해진 순간 충격 또는 기울기
- 각속도(자이로스코프): 해당 축 방향으로 수간 회전한 각도 
- 지자기(마그네틱): 해당 축 방향의 자성 세기
- XNode 모트를 바닦에 놓은 상태에서 x, y 축은 IMU 확장에 인쇄된 그램으로 확인, z축은 하늘과 땅을 잇는 축  
  
**imu_xnode.py**
```python
from xnode.pop.ext import IMU 
from time import sleep_ms

imu = IMU() 
imu.init()  #초기화(반드시 필요함!)

while True:
    x, y, z = imu.read(IMU.ACCELERATION)
    print(x, y, z) #바이트 문자열이 PC로 전달됨. (예: b"-0.4 -0.1 9.4\r\n")
    sleep_ms(20) #20ms
```

**imu_processing_xnode.py**
```python
from xnode.pop.ext import IMU 
import time 

imu = None

def setup():
    global imu
    imu = IMU()
    imu.init() 
 
def loop():
    x, y, z = imu.read(IMU.ACCELERATION)
    print(x, y, z)
    time.sleep_ms(20)

if __name__  == '__main__':
    setup()
    while True:
        loop()
```

**imu_class_xnode.py**
```python
import time
from xnode.pop.ext import IMU

class Processing:
    def __init__(self):
        self.setup()
        while True:
            self.loop()
    
    def setup(self):
        self.imu = IMU()
        self.imu.init()
    
    def loop(self):
        x, y, z = self.imu.read(IMU.ACCELERATION)
        print(x, y, z)
        time.sleep_ms(20)

if __name__ == "__main__":
    Processing()
```

### PC에서 XNode 모트가 전송한 데이터 수신 및 처리

**imu_pc.py**
```python
from serial import Serial 
from time import sleep

ser = Serial("com10", 115_200)

while True:
    ret = ser.readline().decode()
    x = abs(float(ret.split(' ')[0])) 
    if x < 1.0:
        print("small")
    elif x < 5.0:
        print("medium")
    elif x < 10.0:
        print("large") 
    else:
        print("xxx")
        
    sleep(20/1000)
```

**imu_processing_pc.py**
```python
from serial import Serial 
from time import sleep

ser = None

def setup():
    global ser
    ser = Serial("com10", 115_200)
    
def loop():
    ret = ser.readline().decode()
    
    x = abs(float(ret.split(' ')[0])) 
    if x < 1.0:
        print("Safety")
    elif x < 5.0:
        print("Caution")
    elif x < 10.0:
        print("Danger") 
    else:
        print("Calamity")
        
    sleep(20/1000)

if __name__  == '__main__':
    setup()
    while True:
        loop()
```

**imu_class_pc.py**
```python
import sys
import time
import signal
import playsound
from serial import Serial
from multiprocessing import Process

class Processing:
    def __init__(self):
        signal.signal(signal.SIGINT, self.cleanup)
        self.setup()
        while True:
            self.loop()
    
    def setup(self):
        print("call setup")

    def loop(self):
        print("call loop")
        time.sleep(1)

    def cleanup(self, *args):
        sys.exit(0)

class SimpleMp3Player(Processing):
    def __init__(self):
        super().__init__()
    
    def setup(self):
        self.ser = Serial("com10", 115_200)
        self.flags = 0.0
        self.process = None
    
    def loop(self):   # "-0.14 0.15 1.5\r\n" --> ["-0.14", "0.15", "1.5\r"]
        x = abs(float(self.ser.readline().decode().split(" ")[0]))
        if self.flags != x:
            self.flags = x
            
        if 5.0 < self.flags <= 7.0:
            if self.process:
                self.process.terminate()
            self.process = Process(target=playsound.playsound, args=("beatles_yellow_submarine.mp3",))
            self.process.start()
        elif 7.0 < self.flags <= 10.0:
            if self.process:
                self.process.terminate()
            self.process = Process(target=playsound.playsound, args=("led_zeppelin_stairway_to_heaven.mp3",))
            self.process.start()
        elif 10.0 < self.flags:
            if self.process:
                self.process.terminate()
            self.process = Process(target=playsound.playsound, args=("acdc_thunderstruck.mp3",))
            self.process.start()
            
if __name__ == "__main__":
    SimpleMp3Player()
```

## Auto 제어기와 스마트 홈

### 릴레이
- 입력(Pole) 하나, 출력 하나인 SPST(Single Pole Single Throw) 타입
- C(공용), O(A접점)로 구성된 3개 채널 포트 제공
  - 입력은 내부 전원(5V, 12V) 또는 외부 라인 중 선택
  - 출력은 A 접점

### FAN
- FAN은 12V DC 모터 내장
- 검정선은 GND, 빨강선은 릴레이 채널2 또는 3의 O 포트에 연결
  - 입력은 내부 전원 12V 선택(기본값)
  - XNode의 D6(CH2) 또는 D5(CH3) 포트로 릴레이 ON/OFF
  - FAN 객체(기본값은 채널3)의 on(), off() 메소드로 제어
    ```python
    fan = FAN() #기본값은 채널3(D5)
    fan.on()
    fan.off()
    ```

### 조명
- 조명은 12V LED 등
- 검정선은 GND, 빨강선은 릴레이 채널2 또는 3의 O 포트에 연결
  - 입력은 내부 전원 12V 선택(기본값)
  - XNode의 D6(CH2) 또는 D5(CH3) 포트로 릴레이 ON/OFF
  - Light 객체의 on(), off() 메소드로 제어
  ```python
  light = Light() #기본값은 채널2 (D6)
  light.on()
  light.off()
  ```

### 도어락
- 도어락은 자체 전원으로 동작하며, 내부에서는 이벤트 버튼으로 열고 닫음
- 이벤트 선 중 하나는 릴레이 채널1의 C 나머지 하나는 O 포트에 연결
  - 입력은 외부 전원 선택(기본값)
  - XNode D0 포트로 채널 ON/OFF
  - DoorLock 객체의 work() 메소드로 제어
  ```python
  dl = DoorLock() #기본값은 채널1(D0)
  dl.work()
  ```

### PWM 컨트롤러
- ON, OFF 또는 PWM 값으로 LED의 밝기나 모터의 회전 방향 및 속도 제어
- Auto 제어기에 I2C 타입의 12비트 PWM 컨트롤러 내장
- 모터 제어를 위해 A(CH0), /A(CH1)와 B(CH2), /B(CH3)로 구성된 포트 제공
  - 입력은 내부 전원 5V, 12V 중 선택 (기본값은 12V)
  - 출력은 PWM 듀티비 0%(OFF) ~ 100%(ON)

### 가스 잠금 장치 제어
- 가스 잠금장치는 모터 드라이버로 제어
- 검정선은 PWM 컨트롤러의 B, 빨강선은 /B 포트에 연결
  - PWM 컨트롤러의 채널3, 채널2의 배타적인 ON(100%), OFF(0%) 신호로 열고 닫기
  - GasBreaker 객체의 open(), close() 메소드로 제어
  ```python
  gb = GasBreaker()
  gb.open() #시계방향  
  #현재 동작 완료는 약 6초
  gb.close() #반시계방향
  ```

### 디지털 입출력
- 디지털 입출력 장치 연결을 위해 범용 입출력(GPIO) 포트 제공
- 4개 디지털 입출력 포트 제공 (P8, P17, P18, P23)
  - XNode의 GPIO 포트에 연결되며, 운영 전압은 3V3 ~ 5V
  - 다양한 전원 포트 제공 (3V3, 5V, 12V, G(GND))

### 가스 감지기 제어
- 가스 감지기는 단순한 디지털 입력
- 검정선은 GND, 빨강선은 12V, 흰선(입력 신호)은 P18 포트에 연결
  - 가스가 감지되면 경보가 울리며 흰선(P18)이 높은 상태(HIGH)가 됨
  - GasDetect 객체의 read() 메소드로 상태 읽기
  ```python
  gd = GasDetect()
  ret = gd.read() #ret가 1이면 가수 누출, 0이면 정상
  ```
